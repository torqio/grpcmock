// Code generated by protoc-gen-grpcmock. DO NOT EDIT.

package {{ .GoPackageName }}

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/nsf/jsondiff"
	"github.com/oriser/regroup"
	"google.golang.org/protobuf/encoding/protojson"
)

type MethodStub struct {
	RequestFile  string
	ResponseFile string
}

type FileMethod struct {
	Method string `regroup:"method"`
}

var requestRe = regroup.MustCompile(`(?:.*?__)?(?P<method>.+?)__request\.json`)

const RequestSuffix = "_request.json"
const ResponseSuffix = "_response.json"

{{ range $svc := .Services }}
type {{ $svc.GoName }}MockServer struct {
	// An array of requests-response files. The first item is the request and the second is the response
	// The reason that it's array and not a map is because I want to retain the order
	stubFiles map[string][]MethodStub
}

func New{{ $svc.GoName }}MockServer(stubDir string) (*{{ $svc.GoName }}MockServer, error) {
    dirStat ,err := os.Stat(stubDir)
    if err != nil {
        return nil, fmt.Errorf("stat stubs directory %q: %w", stubDir, err)
    }
    if !dirStat.IsDir() {
        return nil, fmt.Errorf("path %q for stubs must be a directory", stubDir)
    }

	mockSrv := &{{ $svc.GoName }}MockServer{stubFiles: make(map[string][]MethodStub)}
	err = filepath.Walk(stubDir, func(path string, info fs.FileInfo, err error) error {
		if info.IsDir() {
			return nil
		}

		dirName := filepath.Dir(path)
		fileName := filepath.Base(path)

		if strings.HasSuffix(fileName, ResponseSuffix) {
			// Skipping without logging
			return nil
		}
		if !strings.HasSuffix(fileName, RequestSuffix) {
			log.Printf("Skipping file %q as it doesn't have %q suffix\n", path, RequestSuffix)
			return nil
		}

		responseFile := fileName[:len(fileName)-len(RequestSuffix)] + ResponseSuffix
		responseFullPath := filepath.Join(dirName, responseFile)

		if _, err := os.Stat(responseFullPath); err != nil {
			if os.IsNotExist(err) {
				return fmt.Errorf("found request file %q, but expected response file %q wasn't found", path, responseFullPath)
			}
			return fmt.Errorf("stat response file: %w", err)
		}

		fileMethod := FileMethod{}
		if err := requestRe.MatchToTarget(path, &fileMethod); err != nil {
			if errors.Is(err, &regroup.NoMatchFoundError{}) {
				return fmt.Errorf("request file %q doesn't contains method name. Request file must be in the following format: [description__]<RPC method name>__request.json. For example: \"some description__CreateAccount__request.json\"")
			}
			return fmt.Errorf("match re to path %q: %w", path, err)
		}

		mockSrv.stubFiles[fileMethod.Method] = append(mockSrv.stubFiles[fileMethod.Method], MethodStub{RequestFile: path, ResponseFile: responseFullPath})
		return nil
	})

	if err != nil {
		return nil, err
	}
	return mockSrv, nil
}

{{ range $method := $svc.Methods }}
func (a *{{ $svc.GoName }}MockServer) {{ $method.GoName }}(ctx context.Context, req *{{ qualifiedIdent $method.Input.GoIdent }}) (*{{ qualifiedIdent $method.Output.GoIdent }}, error) {
	stubFiles := a.stubFiles["{{ $method.GoName }}"]
	if len(stubFiles) == 0 {
		return nil, fmt.Errorf("not stubs for \"{{ $method.GoName }}\"")
	}

	gotJSON, err := protojson.Marshal(req)
	if err != nil {
		return nil, fmt.Errorf("marshal request JSON: %w", err)
	}

	for _, stubFile := range stubFiles {
		stubReqJSON, err := os.ReadFile(stubFile.RequestFile)
		if err != nil {
			return nil, fmt.Errorf("read stub request %q: %w", stubFile.RequestFile, err)
		}

		if !json.Valid(stubReqJSON) {
			return nil, fmt.Errorf("stub file %q contains an invalid JSON", stubFile.RequestFile)
		}

		o := jsondiff.DefaultJSONOptions()
		compareRes, _ := jsondiff.Compare(gotJSON, stubReqJSON, &o)
		if compareRes != jsondiff.FullMatch && compareRes != jsondiff.SupersetMatch {
			// We consider a request as a match in case it's a full match (JSON is identical) or it's a superset -
			// means the stub is a subset if the request JSON
			// (because we may have fields which we don't want to compare like date fields)
			continue
		}

		stubResponseJSON, err := os.ReadFile(stubFile.ResponseFile)
		if err != nil {
			return nil, fmt.Errorf("read stub response %q: %w", stubFile.ResponseFile, err)
		}

		var res {{ qualifiedIdent $method.Output.GoIdent }}
		if err := protojson.Unmarshal(stubResponseJSON, &res); err != nil {
			return nil, fmt.Errorf("unmarshal stub response into \"{{ qualifiedIdent $method.Output.GoIdent }}\": %w", err)
		}

		return &res, nil
	}

	return nil, fmt.Errorf("no matching stub found for the provided request")
}
{{- end }}
{{- end }}